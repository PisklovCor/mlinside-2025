package com.cryptoagents.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.time.LocalDateTime;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

/**
 * Complete analysis report generated by the AgentOrchestrator.
 * 
 * This class contains the results from all agents in the analysis pipeline:
 * Analyst → Risk Manager → Trader, along with execution metadata.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AnalysisReport {
    
    /**
     * The cryptocurrency ticker that was analyzed
     */
    private String ticker;
    
    /**
     * Timestamp when the analysis was started
     */
    @Builder.Default
    private LocalDateTime analysisStartTime = LocalDateTime.now();
    
    /**
     * Timestamp when the analysis was completed
     */
    private LocalDateTime analysisEndTime;
    
    /**
     * Total execution time in milliseconds
     */
    private Long executionTimeMs;
    
    /**
     * List of analysis results from all agents in execution order
     */
    @Builder.Default
    private List<AnalysisResult> agentResults = new ArrayList<>();
    
    /**
     * Overall success status of the analysis
     */
    private boolean successful;
    
    /**
     * Error messages if any agent failed
     */
    @Builder.Default
    private List<String> errors = new ArrayList<>();
    
    /**
     * Performance metrics for each agent
     */
    @Builder.Default
    private Map<String, Long> agentExecutionTimes = new HashMap<>();
    
    /**
     * Additional metadata
     */
    @Builder.Default
    private Map<String, Object> metadata = new HashMap<>();
    
    /**
     * Get the analysis result from a specific agent by name
     * 
     * @param agentName the name of the agent (e.g., "ANALYST", "RISK_MANAGER", "TRADER")
     * @return the analysis result or null if not found
     */
    public AnalysisResult getResultByAgent(String agentName) {
        return agentResults.stream()
                .filter(result -> agentName.equals(result.getAgentName()))
                .findFirst()
                .orElse(null);
    }
    
    /**
     * Add an error message to the report
     * 
     * @param error the error message to add
     */
    public void addError(String error) {
        if (errors == null) {
            errors = new ArrayList<>();
        }
        errors.add(error);
        this.successful = false;
    }
    
    /**
     * Add an agent execution time metric
     * 
     * @param agentName the name of the agent
     * @param executionTime the execution time in milliseconds
     */
    public void addAgentExecutionTime(String agentName, Long executionTime) {
        if (agentExecutionTimes == null) {
            agentExecutionTimes = new HashMap<>();
        }
        agentExecutionTimes.put(agentName, executionTime);
    }
    
    /**
     * Calculate and set the total execution time
     */
    public void calculateExecutionTime() {
        if (analysisStartTime != null && analysisEndTime != null) {
            this.executionTimeMs = java.time.Duration.between(analysisStartTime, analysisEndTime).toMillis();
        }
    }
    
    /**
     * Check if the analysis has any errors
     * 
     * @return true if there are errors, false otherwise
     */
    public boolean hasErrors() {
        return errors != null && !errors.isEmpty();
    }
    
    /**
     * Get total number of agents that executed
     * 
     * @return number of agent results
     */
    public int getAgentCount() {
        return agentResults != null ? agentResults.size() : 0;
    }
} 